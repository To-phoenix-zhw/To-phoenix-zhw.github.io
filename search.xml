<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2019/08/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构的基本概念</title>
    <url>/2019/10/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>　　之前认为的数据只是纯粹的数字，如3, 3.5等，但是现在需要在这个理解之上更深一步，理解3和3.5不同之处到底在哪。</p>
<p>　　数据除了数字大小本身之外，还包含其可进行的<strong>操作</strong>。如3，属于整数，可以进行加减乘除，而3.5，属于实数，它与整数的不同，不仅仅是多了这个小数点，还在于，它多了向上向下取整，四舍五入等新操作；复数，可以取实部取虚部求模；矩阵，可以求逆矩阵，求转置，求行列式。</p>
<p>　　因此区分不同类型的数据，不能仅仅从外观上来看，而要从本质来看：即不同类型的数据必定有不同类型的操作。</p>
<p>　　除此之外，除了数值型数据，还有非数值型数据，如文字、图像和声音。所有数据在计算机中均以二进制形式存储。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>　　结构，重点是数据与数据之间的关系。线性表，数据间关系就是前后顺序关系；树，数据间关系体现层次关系；图，数据间关系就是一种网状关系。</p>
<p>　　数据结构并不特别关心其中的每个数据具体是怎样的，更多地关心数据和数据之间是如何组织起来建立联系的。特别关心其中的每个数据具体是怎样的，则是数据库的研究范畴。</p>
<p>　　再将数据的特点结合起来，得出数据结构的三要素：<strong>数据、关系、操作</strong>。</p>
<p>　　简单理解，数据结构就是一种<strong>关系学</strong>。</p>
<h3 id="数据结构的特性"><a href="#数据结构的特性" class="headerlink" title="数据结构的特性"></a>数据结构的特性</h3><ul>
<li>静态特性</li>
<li>动态特性</li>
</ul>
<p><strong>静态特性</strong>：基于空间的考虑。</p>
<p><strong>动态特性</strong>：基于操作性的考虑。</p>
<p>如：每个人的信息都放在各自的档案袋里，可以将所有的档案袋叠放在一起。这样组织结构，空间占地很小，但当我要取出其中某一个人的信息时，查找起来十分不方便。也可以将每个档案袋单独放在一个抽屉里，这样组织结构，查找时一目了然，但是空间占地很大。</p>
<p>因此我们希望的是，一种数据结构不仅有较好的静态特性（占空间小），又有良好的动态特性（操作性强）。</p>
<h3 id="数据结构的结构分类"><a href="#数据结构的结构分类" class="headerlink" title="数据结构的结构分类"></a>数据结构的结构分类</h3><ul>
<li>逻辑结构</li>
<li>物理结构</li>
</ul>
<p><strong>逻辑结构</strong>：看到的抽象结构本身。如一张线性表，一棵树，一张图。</p>
<p><strong>物理结构</strong>：在计算机中真正的存放结构。</p>
<p>如二维数组，在计算机中就有按行存储和按列存储的方式，但实际上并没有这样的二维结构，真正存放都是一维的。如果是按行存储，a[3] [2]就代表第3行第2列，如果是按列存储，a[3] [2]就代表第2行第3列。这时就有个问题，多维数组呢？如何明晰多维数组在计算机中真正的存放结构呢？以及树，图，在计算机中到底是如何存储的呢？</p>
<p>同时，相同逻辑结构可以对应不同的物理结构，物理结构不同，相应的算法编写也必须做出相应的改变，如之前a[3] [2]的例子。因此一个逻辑结构对应着很多套物理结构和相应的算法程序。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>　　有了以上的种种考虑，就可以知道如何描述一种数据类型了。此处用数学的方式来描述清楚一个数据类型：集合。</p>
<p>　　这个数据类型对应的集合里包含三个大的集合：数据，关系，操作。将这三个大的集合描述清楚之后，这个数据类型也就明朗了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADT A &#123; &#x2F;&#x2F; 定义A这种数据类型</span><br><span class="line">	D &#123;&#125; &#x2F;&#x2F; data objection</span><br><span class="line">	R &#123;&#125; &#x2F;&#x2F; data relationship</span><br><span class="line">	O &#123;&#125; &#x2F;&#x2F; data operation</span><br><span class="line">&#125; ADT A</span><br></pre></td></tr></table></figure>

<p>c++相比c语言的好处之模板</p>
<p>c++支持函数重载，不需要f1,f2,f3,…,f100，当你要调用某一个的时候，要找到对应谁是非常麻烦的。</p>
<p>不同类型要写100个，仍然非常麻烦，因此把数据类型本身作为一个变量，产生模板。</p>
<p>不同操作类型仍然要写很多个，因此再进一步抽象，把运算符抽象。c++中没有直接的运算符抽象，宏指令稍微有运算符抽象的意味在其中。</p>
<p>c++相比c语言的好处之封装</p>
<p>封装：安全性、无意性</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><ul>
<li>有穷性：一定能执行完，有限步骤</li>
<li>确定性：不管机器如何，环境如何，谁执行，结果永远不变</li>
<li>可行性：能够落地，能够把这种计算方法用程序语言描述出来</li>
<li>有输入</li>
<li>有输出</li>
</ul>
<h2 id="描述算法的方法"><a href="#描述算法的方法" class="headerlink" title="描述算法的方法"></a>描述算法的方法</h2><p>自然语言、流程图、约定方式</p>
<h2 id="算法的设计原则"><a href="#算法的设计原则" class="headerlink" title="算法的设计原则"></a>算法的设计原则</h2><p>正确性、健壮性——对于用户而言</p>
<p>阅读性——对于开发者本身而言</p>
<h2 id="算法的评价标准"><a href="#算法的评价标准" class="headerlink" title="算法的评价标准"></a>算法的评价标准</h2><ul>
<li>时间特性</li>
<li>空间特性</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>现代软件工程第7-8周学习</title>
    <url>/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>去年搭建了该博客，中途把他修改了之后拿去参加网页设计大赛，现在要重新恢复他的博客身份，并在全新的本地仓库中进行操作。</p>
<p>hexo上传到github上的只是生成的public文件夹，其中是相关的html文件，要进行修改和持续更新博客，需要重新部署hexo环境。</p>
<h1 id="①-找到最初版本的commit，以该commit创建新分支blog"><a href="#①-找到最初版本的commit，以该commit创建新分支blog" class="headerlink" title="① 找到最初版本的commit，以该commit创建新分支blog"></a>① 找到最初版本的commit，以该commit创建新分支blog</h1><h1 id="②-将该分支作为default默认分支，clone对应分支内容到本地"><a href="#②-将该分支作为default默认分支，clone对应分支内容到本地" class="headerlink" title="② 将该分支作为default默认分支，clone对应分支内容到本地"></a>② 将该分支作为default默认分支，clone对应分支内容到本地</h1><p>问题：github上clone太慢，用码云中转解决</p>
<h2 id="I-码云导入github仓库；"><a href="#I-码云导入github仓库；" class="headerlink" title="I.码云导入github仓库；"></a>I.码云导入github仓库；</h2><h2 id="II-从码云上进行克隆"><a href="#II-从码云上进行克隆" class="headerlink" title="II.从码云上进行克隆"></a>II.从码云上进行克隆</h2><img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/1.png" class title="This is an example image">

<h2 id="III-进入目录，更改get-url"><a href="#III-进入目录，更改get-url" class="headerlink" title="III.进入目录，更改get-url"></a>III.进入目录，更改get-url</h2><img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/2.png" class title="This is an example image">

<h2 id="IV-远程同步"><a href="#IV-远程同步" class="headerlink" title="IV.远程同步"></a>IV.远程同步</h2><p>注意加对应分支名</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/3.png" class title="This is an example image">

<h1 id="③-设置hexo"><a href="#③-设置hexo" class="headerlink" title="③ 设置hexo"></a>③ 设置hexo</h1><h2 id="I-安装hexo"><a href="#I-安装hexo" class="headerlink" title="I.安装hexo"></a>I.安装hexo</h2><img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/4.png" class title="This is an example image">

<h2 id="II-回到上级目录，新建文件夹hexo，并初始化hexo"><a href="#II-回到上级目录，新建文件夹hexo，并初始化hexo" class="headerlink" title="II.回到上级目录，新建文件夹hexo，并初始化hexo"></a>II.回到上级目录，新建文件夹hexo，并初始化hexo</h2><img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/5.png" class title="This is an example image">

<p>​    使用淘宝镜像：否则git卡住无法进行</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/6.png" class title="This is an example image">

<h2 id="III-生成并启动服务"><a href="#III-生成并启动服务" class="headerlink" title="III.生成并启动服务"></a>III.生成并启动服务</h2><img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/7.png" class title="This is an example image">

<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/8.png" class title="This is an example image">

<p>执行以上命令后，hexo就会在public文件夹生成相关html、js、css文件，将来会被提交到github上面。</p>
<h1 id="④-更改主题"><a href="#④-更改主题" class="headerlink" title="④ 更改主题"></a>④ 更改主题</h1><p>选择了一个喜欢的风格配置主题：</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/9.png" class title="This is an example image">

<p>克隆下来之后放到theme文件夹里，并修改根目录下_config.yml文件配置主题</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/10.png" class title="This is an example image">

<p>重新执行<code>hexo g</code>重新生成并预览。界面已生效。</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/11.png" class title="This is an example image">

<h1 id="⑤-上传到github"><a href="#⑤-上传到github" class="headerlink" title="⑤ 上传到github"></a>⑤ 上传到github</h1><h2 id="I-配置-config-yml中有关deploy的部分"><a href="#I-配置-config-yml中有关deploy的部分" class="headerlink" title="I.配置_config.yml中有关deploy的部分"></a>I.配置_config.yml中有关deploy的部分</h2><img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/12.png" class title="This is an example image">

<h2 id="II-安装插件"><a href="#II-安装插件" class="headerlink" title="II.安装插件"></a>II.安装插件</h2><img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/13.png" class title="This is an example image">

<h2 id="III-推到远程仓库"><a href="#III-推到远程仓库" class="headerlink" title="III.推到远程仓库"></a>III.推到远程仓库</h2><img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/14.png" class title="This is an example image">

<p>可以看到该网址已生效</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/15.png" class title="This is an example image">

<h1 id="⑥-常用hexo命令"><a href="#⑥-常用hexo命令" class="headerlink" title="⑥ 常用hexo命令"></a>⑥ 常用hexo命令</h1><p><code>hexo new &quot;postName&quot;</code></p>
<p><code>hexo new page &quot;pageName&quot;</code> #新建页面<br><code>hexo generate</code> #生成静态页面至public目录<br><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br><code>hexo deploy</code> #部署到GitHub<br><code>hexo help</code>  # 查看帮助<br><code>hexo version</code>  #查看Hexo的版本</p>
<p>缩写：</p>
<p><code>hexo n == hexo new</code><br><code>hexo g == hexo generate</code><br><code>hexo s == hexo server</code><br><code>hexo d == hexo deploy</code></p>
<p>组合命令</p>
<p><code>hexo s -g</code> #生成并本地预览</p>
<p><code>hexo d -g</code>#生成并上传</p>
<h1 id="⑦-网站设置"><a href="#⑦-网站设置" class="headerlink" title="⑦ 网站设置"></a>⑦ 网站设置</h1><p>I.添加一个包含站点内所有标签的标签页</p>
<p>生成标签页</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/16.png" class title="This is an example image">

<p>将类型设为tag</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/17.png" class title="This is an example image">

<p>在<strong>主题</strong>的_config.yml文件中加入标签页</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/18.png" class title="This is an example image">

<p>II.添加一个包含站点内所有分类的分类页</p>
<p>创建分类页</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/19.png" class title="This is an example image">

<p>将类型设为categories</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/20.png" class title="This is an example image">

<p><strong>主题</strong>的_config.yml文件中已加入标签页</p>
<p>III.添加关于页等其他菜单项</p>
<p>按照上述相同步骤</p>
<p>IV.配置数学支持</p>
<h1 id="⑦-添加文章内容"><a href="#⑦-添加文章内容" class="headerlink" title="⑦ 添加文章内容"></a>⑦ 添加文章内容</h1><p>首先在hexo文件夹下进行git bash</p>
<p>接着使用上述命令进行添加</p>
<h1 id="⑧-本地图片内容无法显示"><a href="#⑧-本地图片内容无法显示" class="headerlink" title="⑧ 本地图片内容无法显示"></a>⑧ 本地图片内容无法显示</h1><p>I.安装图片路径转换插件</p>
<img src="/2020/10/19/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC7-8%E5%91%A8%E5%AD%A6%E4%B9%A0/21.png" class title="This is an example image">

<p>II.修改文件/node_modules/hexo-asset-image/index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">config.post_asset_folder</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">var</span> link = data.permalink;</span><br><span class="line">	<span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">	<span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">			<span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">			   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">			  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.shift();</span><br><span class="line">			  src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			  $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">			  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">			<span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>III.打开_config.yml文件，修改下述内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>

<p>IV.将图片放到同目录的同名文件夹下，并以如下方式引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 1.png This is an example image %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>现代软件工程</category>
      </categories>
      <tags>
        <tag>-现代软件工程 -博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树经典习题（三操作双标记）</title>
    <url>/2020/10/19/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%8F%E5%85%B8%E4%B9%A0%E9%A2%98(%E4%B8%89%E6%93%8D%E4%BD%9C%E5%8F%8C%E6%A0%87%E8%AE%B0)/</url>
    <content><![CDATA[<p><a href="https://acm.uestc.edu.cn/home">OJ评测</a>：Lutece-2143-方差</p>
<p>　　这道题目可以算是线段树稍难的题目，通过对这道题目的练习，可以提高编写线段树的熟练程度，并加深对线段树的理解。</p>
<h4 id="一、题目内容："><a href="#一、题目内容：" class="headerlink" title="一、题目内容："></a>一、题目内容：</h4><p>维护一个序列，支持快速进行四种操作。</p>
<ul>
<li>将一个区间内的所有数加上一个定值;</li>
<li>将一个区间内的所有数乘上一个定值;</li>
<li>将一个区间内的所有数设为一个定值(区间推平);</li>
<li>输出区间方差乘上这个区间内样本个数的平方，结果对$10^9+7$取模。</li>
<li>数据范围：序列长度≤$10^6$，操作次数≤$10^6$。</li>
</ul>
<h4 id="二、题目分析："><a href="#二、题目分析：" class="headerlink" title="二、题目分析："></a>二、题目分析：</h4><h5 id="Step-1：“单操作”"><a href="#Step-1：“单操作”" class="headerlink" title="Step 1：“单操作”"></a>Step 1：“单操作”</h5><p>——（区间中每个数只能加上一个定值或者只能改为某个定值）</p>
<p>　　如果只有单独的某一个操作，即加上一个定值或者设为一个定值，就是线段树的模板题。做出这道题的重要基础，是掌握<strong>线段树的基本姿势</strong>，即攻克模板题。读者可以自行上网学习博客，笔者现提供一个博客地址作参考:<a href="https://www.cnblogs.com/iris001999/articles/9058603.html">线段树</a>。</p>
<p>　　单操作模板题地址：<a href="https://www.luogu.org/problem/P3372">模板：线段树1</a></p>
<br>

<h5 id="Step-2：“双操作”（重要衔接）"><a href="#Step-2：“双操作”（重要衔接）" class="headerlink" title="Step 2：“双操作”（重要衔接）"></a>Step 2：“双操作”（重要衔接）</h5><h5 id="——（区间中每个数既可以加上一个定值又能够乘上一个定值"><a href="#——（区间中每个数既可以加上一个定值又能够乘上一个定值" class="headerlink" title="——（区间中每个数既可以加上一个定值又能够乘上一个定值)"></a>——（区间中每个数既可以加上一个定值又能够乘上一个定值)</h5><p>　　在进行三操作之前，我们可以先来考虑双操作，即同时实现加上定值和乘上定值。这相当于是在单操作和三操作之间进行了一个<font color="#FF0000">衔接</font>。掌握了双操作，三操作会是一件非常自然的事情，只要在双操作基础上做一点小小地改动，就能实现。</p>
<br>

<p>细心的读者可能会问：为什么这个衔接不可以是加上某个定值和改变成某个定值的组合，而非得是加上某个定值和乘上某个定值的组合呢？</p>
<br>

<p>　　读者可以先思考，如何实现改变成某个定值。当然，可以直接赋值，但是如果<u>借助四则运算</u>，就会发现，改变成某个定值可以用加法和乘法实现。</p>
<p>　　一步一步来，我们会详细探讨。</p>
<p>　　双操作题目地址：<a href="https://www.luogu.org/problem/P3373">线段树2</a></p>
<br>

<h4 id="①-头脑风暴："><a href="#①-头脑风暴：" class="headerlink" title="① 头脑风暴："></a>① 头脑风暴：</h4><h5 id="双操作实现：加与乘"><a href="#双操作实现：加与乘" class="headerlink" title="双操作实现：加与乘"></a>双操作实现：加与乘</h5><p>维护信息：区间和，懒标记</p>
<p>接下来我们一起思考一些关键性的问题，这些问题其实就是多重标记的核心问题，经过这番思考之后，相信我们对这种多标记类型的线段树问题会有更深刻的认识。</p>
<br>

<p><font color="#FF0000">Q1: 几个懒标记？</font></p>
<p>　　我们知道，懒标记是用来向下延迟修改的，所以在当前结点需要做个记号，表示我该下传的还没有下传。那什么时候下传呢？一旦之后某个操作需要继续向下深入，进行一些查找或者修改操作的时候，经过这个结点时，自然可以利用这个结点保存的懒标记信息，进行下面结点的信息更新(push_down)。<del>懒标记相当于暂时记个账。</del></p>
<p>　　对下，我们延迟了修改，但是对上，需要汇报准确的信息，所以还需要向上更新，即有一个上传操作（push_up）。</p>
<p>　　两个懒标记，一个保存延迟的加操作信息，一个保存延迟的乘操作信息。我们把它们分别命名为lazy_sum, lazy_mul，便于后续讨论。</p>
<br>

<p><font color="#FF0000">Q2: 两个懒标记如何不打架且良好配合？</font></p>
<p>　　我们可以看一个实例来帮助我们理解**<u>优先级</u>**的问题：</p>
<p>　　现在有一个数：4，它的子结点值为3，执行两组操作</p>
<p>　　I.先乘5后加3</p>
<p>　　II.先加3后乘5</p>
<p>​    <br></p>
<p>假设之前的懒标记均为<strong>初始值</strong>，即<code>lazy_sum = 0, lazy_mul = 1</code>（想一想，初始值为什么是这样）.</p>
<p>I. 先乘5后加3：<code>4 * 5 = 20， 20 + 3 = 23</code></p>
<p>　　子结点同样：<code>3 * 5 = 15， 15 + 3 = 18</code></p>
<p>　　在程序写法上，我们遵从先乘后加。</p>
<br>

<p>II.先加3后乘5：<code>lazy_sum = 3;</code></p>
<p>　　  　　　　  <code>lazy_mul = 5;</code></p>
<p>　　更新值的时候，我们可能会想，这很自然啊，<code>4 + 3 = 7, 7 * 5 = 35</code></p>
<p>　　可是标记下传的时候就有问题了，我从父结点这里得到了两个标记，一个加标记一个乘标记，我怎么知道是谁先来谁后来呢？假设下传的这个结点值为3。现在它可以进行3 + 3 = 6, 6 * 5 = 30, 也可以进行3 * 5 = 15, 15 + 3 = 18。我们又可以想，那我们就做个标志变量嘛，0表示加先来，1表示乘先来或者写两个函数，一个先加后乘，一个先乘后加。但仔细思考，发现这种思路可行性不高，现在是一个加一个乘，当然可以这样，但是实际情况是，操作会不断累积不断累积，很多加过来，很多乘过来，交错进行，这时标志变量和调用两个函数还有办法吗？即使就想这样暴力，也会发现是极其浪费时间空间和精力的。</p>
<p>　　 <strong style="background:#F0F0F0">所以这时我们就想出来了一个比较好的思路：</strong></p>
<p>　　在写程序的时候，必定一个操作先写，一个操作后写，在这里我们就按照四则运算本身的<font face="STCAIYUN" color="#ff2d2d"> <strong style="background:#F0F0F0">优先级</strong></font>，先写乘，再写加。</p>
<p>　　假设现在加操作过来了，在这个加操作之前，可能有加，也可能有乘，但是“+”在四则运算里面，优先级就是低于“×”的，所以这个加操作直接加在结果末尾就好了。</p>
<p>　　假设现在乘操作过来了，在这个乘操作之前，可能有加，也可能有乘，那么对于之前的加，我们需要<font face="STCAIYUN" color="#ff2d2d"> <strong style="background:#F0F0F0">一起乘</strong></font>，这是什么意思呢？</p>
<p>　　还是刚才的例子，值为4，<code>lazy_sum = 3</code>, 现在需要乘上一个5</p>
<p>　　<code>lazy_mul *= 5;</code> 很自然</p>
<p>　　<code>sum *= 5;</code> 当前结点（符合要求的区间对应的结点）的sum作相应改变，也很自然</p>
<p>　　<code>lazy_sum *= 5;</code><strong>这句话就需要着重理解</strong></p>
<p>　　接下来下传的时候，值为3的子结点得到了父结点传下来的两个懒标记信息：<code>lazy_sum = 15, lazy_mul = 5;</code></p>
<p>　　由此，事情就这样演变：<code>3 * 5 = 15; 15 + 15 = 30;</code></p>
<p>　　与我们脑海里面构想的，<code>3 + 3 = 6；6 * 5 = 30；</code>答案是一致的</p>
<p>​    <br></p>
<p>　　现在我们可以反过来验证，如果之前没有lazy_sum *= 5, lazy_sum还是等于3，事情就这样演变：3 * 5 = 15; 15 + 3 = 18; 与我们的预想不一致。</p>
<p>　　所以这里实际上用了个分配率，相当于(3 + <code>3</code>) * 5 = 3 * 5 + <u><code>3</code> * 5</u>  = 30，方框中的3为懒标记的3.</p>
<br>

<p>　　我们之所以要经历这样坎坷的心路历程，是为了保证我们push_down的时候，能够不知不觉，潜移默化地保证所有操作的先后顺序。两个懒标记变量毕竟始终是两个定值，因此我们需要随时对这两个值进行有效的修改，修改之后，便可以始终秉承乘先加后的优先级规则，进行运算，得出正确结果。</p>
<p>​        **所以我们解决的是，操作的先后与乘法加法的先后之间的矛盾问题。</p>
<br>

<h4 id="②代码示例"><a href="#②代码示例" class="headerlink" title="②代码示例"></a>②代码示例</h4><p>可以将线段树的相关信息写在结构体里，这是比较好的代码风格和习惯，这里我们采取多个通过结点编号关联起来的数组的形式作为示例，供读者参考。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p3373-Segment_Tree2</span></span><br><span class="line"><span class="comment">// 确定优先级，以及相互之间的影响关系</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line">LL a[MAXN], sum[MAXN*<span class="number">4</span>];</span><br><span class="line">LL lazy_add[MAXN*<span class="number">4</span>], lazy_mul[MAXN*<span class="number">4</span>];</span><br><span class="line">LL MOD;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(LL root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记上传，向上汇报信息</span></span><br><span class="line">    sum[root] = (sum[root &lt;&lt; <span class="number">1</span>] + sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) % MOD;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(LL root, LL len)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 不直接加等乘等，分开写，在涉及取模这里更能保证正确性 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lazy_add[root] == <span class="number">0</span> &amp;&amp; lazy_mul[root] == <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 判断父结点是否传了有效的懒标记信息</span></span><br><span class="line">    	<span class="comment">// 当然可以在调用这个函数之前判断，以决定要不要调用这个函数</span></span><br><span class="line">    <span class="keyword">if</span> (lazy_mul[root] != <span class="number">1</span>) &#123; <span class="comment">// 乘标记有信息</span></span><br><span class="line">        lazy_mul[root &lt;&lt; <span class="number">1</span>] = (lazy_mul[root &lt;&lt; <span class="number">1</span>] * lazy_mul[root]) % MOD;</span><br><span class="line">        lazy_mul[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (lazy_mul[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] * lazy_mul[root]) % MOD; </span><br><span class="line">        <span class="comment">// 传进来的root的左右子结点更新乘标记（直接乘）</span></span><br><span class="line">        sum[root &lt;&lt; <span class="number">1</span>] = (sum[root &lt;&lt; <span class="number">1</span>] * lazy_mul[root] % MOD) % MOD;</span><br><span class="line">        sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] * lazy_mul[root] % MOD) % MOD; </span><br><span class="line">        <span class="comment">// 传进来的root的左右子结点更新维护的区间和信息（直接乘）</span></span><br><span class="line">        lazy_add[root &lt;&lt; <span class="number">1</span>] = lazy_add[root &lt;&lt; <span class="number">1</span>] * lazy_mul[root] % MOD;</span><br><span class="line">        lazy_add[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = lazy_add[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] * lazy_mul[root] % MOD;</span><br><span class="line">		<span class="comment">// 乘对加的影响（着重思考和探讨的地方）</span></span><br><span class="line">        lazy_mul[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// “销账”，父结点对应懒标记恢复初始状态</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (lazy_add[root] != <span class="number">0</span>) &#123;<span class="comment">// 加标记有信息</span></span><br><span class="line">        sum[root &lt;&lt; <span class="number">1</span>] = (sum[root &lt;&lt; <span class="number">1</span>] + lazy_add[root] * (len - (len) / <span class="number">2</span>)) % MOD;</span><br><span class="line">        sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + lazy_add[root] * (len / <span class="number">2</span>)) % MOD;</span><br><span class="line">      <span class="comment">// 传进来的root的左右子结点更新区间和（注意左右子结点不同的区间长度：可手画做几个例子）</span></span><br><span class="line">        lazy_add[root &lt;&lt; <span class="number">1</span>] = (lazy_add[root &lt;&lt; <span class="number">1</span>] + lazy_add[root]) % MOD;</span><br><span class="line">        lazy_add[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (lazy_add[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + lazy_add[root]) % MOD;</span><br><span class="line">      <span class="comment">// 传进来的root的左右子结点更新加标记（直接加）</span></span><br><span class="line">        </span><br><span class="line">        lazy_add[root] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// “销账”，父结点对应懒标记恢复初始状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL l, LL r, LL root)</span> </span>&#123;</span><br><span class="line">    lazy_add[root] = <span class="number">0</span>; lazy_mul[root] = <span class="number">1</span>; <span class="comment">// 初始化标记在双重标记里面显得尤为重要</span></span><br><span class="line">    <span class="comment">// 这个初始化就不能仅仅放在l==r的大括号里面了</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        sum[root] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(l, mid, root &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    build(mid + <span class="number">1</span>, r, root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upgrade1</span><span class="params">(LL la, LL rb, LL l, LL r, LL val, LL root)</span> </span>&#123; <span class="comment">// 加操作</span></span><br><span class="line">    <span class="keyword">if</span> (la &lt;= l &amp;&amp; rb &gt;= r) &#123;</span><br><span class="line">        lazy_add[root] += val;</span><br><span class="line">        sum[root] += val * (r - l + <span class="number">1</span>) % MOD;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push_down(root, r - l + <span class="number">1</span>);</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (la &lt;= mid) upgrade1(la, rb, l, mid, val, root &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rb &gt; mid) upgrade1(la, rb, mid + <span class="number">1</span>, r, val, root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upgrade2</span><span class="params">(LL la, LL rb, LL l, LL r, LL val, LL root)</span> </span>&#123; <span class="comment">// 乘操作</span></span><br><span class="line">    <span class="keyword">if</span> (la &lt;= l &amp;&amp; rb &gt;= r) &#123;</span><br><span class="line">        lazy_mul[root] = (val % MOD * lazy_mul[root] % MOD) % MOD;</span><br><span class="line">        lazy_add[root] = lazy_add[root] * val % MOD;</span><br><span class="line">        sum[root] = (sum[root] * val % MOD) % MOD;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push_down(root, r - l + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (la &lt;= mid) upgrade2(la, rb, l, mid, val, root &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rb &gt; mid) upgrade2(la, rb, mid + <span class="number">1</span>, r, val, root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL la, LL rb, LL l, LL r, LL root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (la &lt;= l &amp;&amp; rb &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum[root];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push_down(root, r - l + <span class="number">1</span>);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (la &lt;= mid) ans += query(la, rb, l, mid, root &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rb &gt; mid) ans += query(la, rb, mid + <span class="number">1</span>, r, root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 注意查询函数与更新函数不同，不需要上传，我们可以细细品味下其中的缘由</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;N, &amp;M, &amp;MOD);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    build(<span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (M--) &#123; <span class="comment">// 按照题目要求相应调用即可</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        LL x, y, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">            upgrade2(x, y, <span class="number">1</span>, N, k, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">            upgrade1(x, y, <span class="number">1</span>, N, k, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            LL ans = query(x, y, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans % MOD);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<br>

<h5 id="Step-3：“三操作”"><a href="#Step-3：“三操作”" class="headerlink" title="Step 3：“三操作”"></a>Step 3：“三操作”</h5><h4 id="①头脑风暴："><a href="#①头脑风暴：" class="headerlink" title="①头脑风暴："></a>①头脑风暴：</h4><p>第一步到第二步算是一个陡增，第二步到第三步只需增加两个式子即可。</p>
<p>下面是一些关于方差本身性质的推导，以得出更新区间平方和以及求出最终答案的正确方式。</p>
<br>



<p><strong>变成某个定值如何实现？</strong></p>
<p>　　之前我们思考过一个问题此处我们必然是要往乘和加两个基本四则运算上去思考。</p>
<p>　　<font color="#FF0000">变成某个值可以先乘上0再加上这个值。</font></p>
<p>　　因此，当遇到区间推平操作的时候，只需要先调用一次乘操作函数，再调用一次加操作函数即可。</p>
<br>



<p><strong>区间和、区间平方和与要求输出内容的联系？</strong></p>
<p>要求输出内容：区间方差乘上这个区间内样本个数的平方</p>
<p>　　接下来就是草稿本上的一系列推导过程了。</p>
<p>　　<font face="STCAIYUN" color="#ff2d2d"> <strong style="background:#F0F0F0">方差公式</strong></font>：$D(X) = E(X^2) - [E(X)]^2$</p>
<p><font face="STCAIYUN" color="#ff2d2d"> <strong style="background:#F0F0F0">等式两边同时乘上$n^2$，左 = 右 = 区间平方和 * 样本个数 - 区间和的平方</strong></font></p>
<p>　　一时想不过来可以将Ｄ和Ｅ全部用x1+x2+x3+···+xn/n的形式展开，自然会得出上述结论。这也就决定了我们需要用线段树多维护一个区间平方和的信息。</p>
<br>



<p><strong>如何更新区间平方和？</strong></p>
<p>　　<strong>乘操作:</strong></p>
<p>　　区间内每个元素乘上k再相加，相当于给原式加括号并在外面乘上$k^2$.<br>$$<br>(x_1＊k)^2+(x_2＊k)^2+(x_3＊k)^2<br>= k^2(x_1^2+x_2^2+x_3^2)<br>$$<br>　　<strong>加操作:</strong></p>
<p>　　稍微麻烦一些，不过不是特别复杂的化简。<br>$$<br>(x_1+k)^2+(x_2+k)^2+(x_3+k)^2<br>= x_1^2+x_2^2+x_3^2+3k^2+2k(x_1+x_2+x_3)<br>$$<br>​        一般化，则将上面的$3k^2$改为$区间长度*k^2$</p>
<p>　　上述两公式即解决了更新区间平方和的问题。</p>
<p><strong>注：</strong></p>
<p>​        1. 此处固定先更新区间平方和再更新区间和，因为区间平方和的更新要用到先前的区间和，顺序不能颠倒。</p>
<p>​        2. 题目要求取模，要注意能取模的地方都取模，该取模的地方一定取模，多取模都没有关系，一旦少取，可能导致结果一直不正确。（取模参见同余定理）</p>
<p>​        3. 此处最好不要写乘等和除等，涉及多处取模，可能容易出错。</p>
<br>

<h4 id="②代码示例-1"><a href="#②代码示例-1" class="headerlink" title="②代码示例"></a>②代码示例</h4><p>　　三操作代码与双操作基本无异，只是多了区间平方和的维护，用我们得出的两个式子即可实现。MOD写得较多，有些必要有些不必要，只要必要的地方保证写到即可。</p>
<p>　　读者可以仅参考等号左边的变量，注意更改顺序，而不必纠结细节。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Data_Structure-A-2143-variance</span></span><br><span class="line"><span class="comment">// 把所有数据都开long long</span></span><br><span class="line"><span class="comment">// 包括题目给的初始定标数据N，Q </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1E9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL num[MAXN]; </span><br><span class="line">LL lazy_add[MAXN*<span class="number">4</span>], lazy_mul[MAXN*<span class="number">4</span>], sum[MAXN*<span class="number">4</span>], square_sum[MAXN*<span class="number">4</span>]; </span><br><span class="line">LL N, Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(LL root)</span> </span>&#123;</span><br><span class="line">    sum[root] = (sum[root &lt;&lt; <span class="number">1</span>] % MOD + sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD) % MOD;</span><br><span class="line">    square_sum[root] = (square_sum[root &lt;&lt; <span class="number">1</span>] % MOD + square_sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD) % MOD;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(LL root, LL len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazy_mul[root] != <span class="number">1</span>) &#123;</span><br><span class="line">        lazy_mul[root &lt;&lt; <span class="number">1</span>] = ((lazy_mul[root &lt;&lt; <span class="number">1</span>] % MOD) * (lazy_mul[root] % MOD)) % MOD;</span><br><span class="line">        lazy_mul[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = ((lazy_mul[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD) * (lazy_mul[root] % MOD)) % MOD;</span><br><span class="line">        square_sum[root &lt;&lt; <span class="number">1</span>] = (((square_sum[root &lt;&lt; <span class="number">1</span>] % MOD) * (lazy_mul[root] % MOD)) % MOD * (lazy_mul[root] % MOD)) % MOD;</span><br><span class="line">        square_sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (((square_sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD) * (lazy_mul[root] % MOD))%MOD * (lazy_mul[root] % MOD)) % MOD;</span><br><span class="line">        sum[root &lt;&lt; <span class="number">1</span>] = ((sum[root &lt;&lt; <span class="number">1</span>] % MOD) * (lazy_mul[root] % MOD)) % MOD;</span><br><span class="line">        sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = ((sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD) * (lazy_mul[root] % MOD)) % MOD;</span><br><span class="line">        lazy_add[root &lt;&lt; <span class="number">1</span>] = ((lazy_add[root &lt;&lt; <span class="number">1</span>] % MOD) * (lazy_mul[root] % MOD)) % MOD;</span><br><span class="line">        lazy_add[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = ((lazy_add[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD) * (lazy_mul[root] % MOD)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lazy_add[root] != <span class="number">0</span>) &#123;</span><br><span class="line">        lazy_add[root &lt;&lt; <span class="number">1</span>] = (lazy_add[root &lt;&lt; <span class="number">1</span>] % MOD + lazy_add[root] % MOD) % MOD;</span><br><span class="line">        lazy_add[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (lazy_add[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD + lazy_add[root] % MOD) % MOD;</span><br><span class="line">        square_sum[root &lt;&lt; <span class="number">1</span>] = ((square_sum[root &lt;&lt; <span class="number">1</span>] + ((((len - (len) / <span class="number">2</span>)  % MOD) * (lazy_add[root] % MOD)) % MOD * (lazy_add[root] % MOD) % MOD ) % MOD) % MOD + ((<span class="number">2</span> * ((lazy_add[root]) % MOD)) % MOD * (sum[root &lt;&lt; <span class="number">1</span>] % MOD) % MOD) % MOD) % MOD;</span><br><span class="line">        square_sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = ((square_sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + ((len / <span class="number">2</span>) * (lazy_add[root] % MOD) % MOD) * (lazy_add[root] % MOD) % MOD) % MOD + ((<span class="number">2</span> * (lazy_add[root] % MOD) % MOD) * (sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD)) % MOD) % MOD;</span><br><span class="line">        sum[root &lt;&lt; <span class="number">1</span>] = (sum[root &lt;&lt; <span class="number">1</span>] % MOD + (lazy_add[root] % MOD) * ((len - (len) / <span class="number">2</span>) % MOD) % MOD) % MOD;</span><br><span class="line">        sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (sum[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] % MOD + (lazy_add[root] % MOD) * ((len / <span class="number">2</span>) % MOD) % MOD) % MOD; </span><br><span class="line">    &#125;</span><br><span class="line">    lazy_mul[root] = <span class="number">1</span>; lazy_add[root] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(LL root, LL l, LL r)</span> </span>&#123;</span><br><span class="line">    lazy_add[root] = <span class="number">0</span>; lazy_mul[root] = <span class="number">1</span>; sum[root] = <span class="number">0</span>; square_sum[root] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    	sum[root] = num[l];</span><br><span class="line">    	square_sum[root] = ((num[l] % MOD) * (num[l] % MOD)) % MOD;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(root &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upgrade1</span><span class="params">(LL root, LL la, LL rb, LL l, LL r, LL v)</span> </span>&#123; <span class="comment">// 加操作</span></span><br><span class="line">    <span class="keyword">if</span> (la &lt;= l &amp;&amp; rb &gt;= r) &#123;</span><br><span class="line">        lazy_add[root] = (lazy_add[root] % MOD + v % MOD) % MOD;</span><br><span class="line">        square_sum[root] = (square_sum[root] % MOD + (((r - l + <span class="number">1</span>) % MOD * (v % MOD) % MOD) * (v % MOD) % MOD) % MOD + ((<span class="number">2</span> * (v % MOD)) % MOD * (sum[root] % MOD)) % MOD) % MOD;</span><br><span class="line">        sum[root] = (sum[root] % MOD + ((v % MOD) * ((r - l + <span class="number">1</span>)) % MOD) %MOD) % MOD;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push_down(root, r - l + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (la &lt;= mid) upgrade1(root &lt;&lt; <span class="number">1</span>, la, rb, l, mid, v);</span><br><span class="line">    <span class="keyword">if</span> (rb &gt; mid) upgrade1(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, la, rb, mid + <span class="number">1</span>, r, v);</span><br><span class="line"></span><br><span class="line">    push_up(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upgrade2</span><span class="params">(LL root, LL la, LL rb, LL l, LL r, LL v)</span> </span>&#123; <span class="comment">// 乘操作</span></span><br><span class="line">    <span class="keyword">if</span> (la &lt;= l &amp;&amp; rb &gt;= r) &#123;</span><br><span class="line">        lazy_mul[root] = (lazy_mul[root] % MOD * (v % MOD)) % MOD;</span><br><span class="line">        lazy_add[root] = (lazy_add[root] % MOD * (v % MOD)) % MOD;</span><br><span class="line">        square_sum[root] = (((square_sum[root] % MOD) * (v % MOD)) % MOD * (v % MOD)) % MOD;</span><br><span class="line">        sum[root] = ((sum[root] % MOD) * (v % MOD)) % MOD;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push_down(root, r - l + <span class="number">1</span>);</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (la &lt;= mid) upgrade2(root &lt;&lt; <span class="number">1</span>, la, rb, l, mid, v);</span><br><span class="line">    <span class="keyword">if</span> (rb &gt; mid) upgrade2(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, la, rb, mid + <span class="number">1</span>, r, v);</span><br><span class="line"></span><br><span class="line">    push_up(root);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// id为1，查询平方和，id为2，查询和</span></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL root, LL la, LL rb, LL l, LL r, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (la &lt;= l &amp;&amp; rb &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="keyword">return</span> square_sum[root];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) <span class="keyword">return</span> sum[root];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    push_down(root, r - l + <span class="number">1</span>);</span><br><span class="line">    LL answer = <span class="number">0</span>;</span><br><span class="line">    LL mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (la &lt;= mid) answer += query(root &lt;&lt; <span class="number">1</span>, la, rb, l, mid, id);</span><br><span class="line">    <span class="keyword">if</span> (rb &gt; mid) answer += query(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, la, rb, mid + <span class="number">1</span>, r, id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">&quot;data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;N, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= N; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;num[i]);</span><br><span class="line">	<span class="built_in">memset</span>(lazy_add, <span class="number">0</span>, <span class="keyword">sizeof</span>(lazy_add));</span><br><span class="line">	<span class="built_in">memset</span>(lazy_mul, <span class="number">0</span>, <span class="keyword">sizeof</span>(lazy_mul));</span><br><span class="line">	<span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">	<span class="built_in">memset</span>(square_sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(square_sum));</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, N);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> id; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;id);</span><br><span class="line">        LL ql, qr, k;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;ql, &amp;qr, &amp;k);</span><br><span class="line">            upgrade1(<span class="number">1</span>, ql, qr, <span class="number">1</span>, N, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;ql, &amp;qr, &amp;k);</span><br><span class="line">            upgrade2(<span class="number">1</span>, ql, qr, <span class="number">1</span>, N, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;ql, &amp;qr, &amp;k);</span><br><span class="line">            upgrade2(<span class="number">1</span>, ql, qr, <span class="number">1</span>, N, <span class="number">0</span>);</span><br><span class="line">            upgrade1(<span class="number">1</span>, ql, qr, <span class="number">1</span>, N, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;ql, &amp;qr);</span><br><span class="line">            LL interval_square_sum = query(<span class="number">1</span>, ql, qr, <span class="number">1</span>, N, <span class="number">1</span>);</span><br><span class="line">            LL interval_sum = query(<span class="number">1</span>, ql, qr, <span class="number">1</span>, N, <span class="number">2</span>);</span><br><span class="line">            LL ans = (MOD + (interval_square_sum % MOD) * ((qr - ql + <span class="number">1</span>) % MOD) % MOD - (interval_sum % MOD * (interval_sum % MOD)) % MOD) % MOD;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>-数据结构 -线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>现代软件工程第8-9周</title>
    <url>/2020/10/26/%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%AC8-9%E5%91%A8/</url>
    <content><![CDATA[<p>本周实现了黄金点游戏的程序，可以在DOS窗口中进行游戏</p>
<p>代码中用c++标准库的优先队列来进行排序，一个一个弹栈，最先弹出的是最高分，给N分，最后弹出的是最低分，给-2分。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span>; <span class="comment">// 最大人数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">1010</span>; <span class="comment">// 最大轮数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> golden = <span class="number">0.618</span>;</span><br><span class="line"><span class="keyword">double</span> num[MAXN][MAXK]; </span><br><span class="line"><span class="keyword">int</span> N; <span class="comment">// 玩游戏的人数</span></span><br><span class="line"><span class="keyword">int</span> K; <span class="comment">// 游戏的轮数</span></span><br><span class="line"><span class="keyword">double</span> cur_score[MAXN][MAXK]; <span class="comment">// 每个人当前局的得分</span></span><br><span class="line"><span class="keyword">double</span> acc_score[MAXN][MAXK]; <span class="comment">// 每个人累计到当前局的总分</span></span><br><span class="line"><span class="keyword">double</span> dist[MAXN]; <span class="comment">// 每个人当前和G值的差距</span></span><br><span class="line"><span class="keyword">double</span> G[MAXK]; <span class="comment">// 每一轮的G值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">double</span> score;</span><br><span class="line">	Node(<span class="keyword">int</span> id, <span class="keyword">double</span> score) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">		<span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; B) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> score &lt; B.score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入玩游戏的人数和总共的局数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;K);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123; <span class="comment">// 第i局 </span></span><br><span class="line">        <span class="keyword">double</span> all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123; <span class="comment">// 第j个人 </span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;num[j][i]);</span><br><span class="line">            all += num[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> average = all / N;</span><br><span class="line">        <span class="keyword">double</span> G = average * golden;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            dist[j] = <span class="built_in">fabs</span>(G-num[j][i]);</span><br><span class="line">            Q.push(Node(j, dist[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        Node highest = Q.top(); <span class="comment">// 最高分取出来给N分 </span></span><br><span class="line">        Q.pop();</span><br><span class="line">        cur_score[highest.id][i] = N;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = highest.id;</span><br><span class="line">        <span class="keyword">while</span> (Q.empty() == <span class="literal">false</span>) &#123; <span class="comment">// 剩下的依次出队，最后一个给-2分 </span></span><br><span class="line">        	Node cur = Q.top();</span><br><span class="line">        	Q.pop();</span><br><span class="line">        	<span class="keyword">int</span> cur_id = cur.id;</span><br><span class="line">        	temp = cur_id;</span><br><span class="line">        	cur_score[cur_id][i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        cur_score[temp][i] = <span class="number">-2</span>; <span class="comment">// temp记录的最后一个附0分 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            acc_score[j][i] = acc_score[j][i<span class="number">-1</span>] + cur_score[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;第%d轮的第%d个人的该局得分:%lf\n&quot;</span>, i, j, cur_score[j][i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;第%d轮的第%d个人的累计得分:%lf\n&quot;</span>, i, j, acc_score[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>现代软件工程</category>
      </categories>
      <tags>
        <tag>-现代软件工程</tag>
      </tags>
  </entry>
</search>
